use std::io::Write;

use crate::{
    common::{Field, Packed},
    wiretypes::{ToVarint, WireTyped},
};

use leb128;

#[derive(Debug)]
pub enum EncodeError {
    BufferOutOfSpace,
}

pub type Result<T> = std::result::Result<T, EncodeError>;

#[derive(Debug)]
pub struct EncodeBuffer<'a> {
    buffer: &'a mut [u8],
    len: usize,
}

impl Write for EncodeBuffer<'_> {
    fn write(&mut self, append_bytes: &[u8]) -> std::io::Result<usize> {
        let count = append_bytes.len();
        let new_len = self.len + count;
        if new_len >= self.buffer.len() {
            return Err(std::io::Error::new(
                std::io::ErrorKind::OutOfMemory,
                "out of memory",
            ));
        }
        self.buffer[self.len..new_len].copy_from_slice(append_bytes);
        self.len = new_len;
        Ok(count)
    }

    fn flush(&mut self) -> std::io::Result<()> {
        Ok(())
    }
}

impl EncodeBuffer<'_> {
    pub fn from_static(static_buffer: &mut [u8]) -> EncodeBuffer<'_> {
        EncodeBuffer {
            buffer: static_buffer,
            len: 0,
        }
    }

    pub fn as_slice(&self) -> &[u8] {
        &self.buffer[..self.len]
    }

    pub fn encode_tag(&mut self, encodable: impl ToWire, field: Field) -> std::io::Result<usize> {
        encodable.write_tag(self, field)
    }

    pub fn encode_value(&mut self, encodable: impl ToWire) -> std::io::Result<usize> {
        encodable.append(self)
    }

    pub fn encode(
        &mut self,
        encodable: impl ToWire + Copy,
        field: Field,
    ) -> std::io::Result<usize> {
        self.encode_tag(encodable, field)?;
        self.encode_value(encodable)
    }
}

/// The ToWire trait encodes the type in the protocol buffers wire format
pub trait ToWire: WireTyped {
    /// encodes the tag for the type and returns the bytes written
    fn write_tag(&self, buf: &mut EncodeBuffer, field: Field) -> std::io::Result<usize> {
        let tag = self.tag(field);
        dbg!(&tag.0);
        let (bytes, count) = tag.encode();
        dbg!(&bytes);
        buf.write(&bytes[0..count])
    }

    /// encodes to the end of the encode buffer and returns the number of bytes written
    fn append(&self, buf: &mut EncodeBuffer) -> std::io::Result<usize>;

    /// precalculates the number of bytes required to encode this
    /// will be called before encode_append in some cases
    fn precalculate_size(&self) -> usize;
}

/// Writes the length prefix. Used for length encoded types.
pub fn write_prefix(buf: &mut EncodeBuffer, len: usize) -> std::io::Result<usize> {
    let (bytes, count) = (len as u64).to_varint_encoding();
    buf.write(&bytes[..count])
}

impl<T> ToWire for Packed<&[T]>
where
    T: ToWire,
{
    fn append(&self, buf: &mut EncodeBuffer) -> std::io::Result<usize> {
        write_prefix(buf, self.precalculate_size())?;
        let mut count = 0;
        for t in self.0.iter() {
            count += t.append(buf)?;
        }
        Ok(count)
    }

    fn precalculate_size(&self) -> usize {
        self.0.iter().map(|t| t.precalculate_size()).sum()
    }
}

impl ToWire for &String {
    fn append(&self, buf: &mut EncodeBuffer) -> std::io::Result<usize> {
        write_prefix(buf, self.len())?;
        buf.write(self.as_bytes())
    }

    fn precalculate_size(&self) -> usize {
        self.as_bytes().len()
    }
}

impl ToWire for &[u8] {
    fn append(&self, buf: &mut EncodeBuffer) -> std::io::Result<usize> {
        dbg!(self.len());
        write_prefix(buf, self.len())?;
        buf.write(self)
    }

    fn precalculate_size(&self) -> usize {
        self.len()
    }
}

impl ToWire for i32
where
    i32: ToVarint,
{
    fn append(&self, buf: &mut EncodeBuffer) -> std::io::Result<usize> {
        leb128::write::signed(buf, *self as i64)
    }

    fn precalculate_size(&self) -> usize {
        let (_, size) = self.to_varint_encoding();
        size
    }
}

pub trait Encode {
    fn encode(&self, buf: &mut EncodeBuffer) -> std::io::Result<usize>;
    // fn decode(&self, buf: &mut EncodeBuffer) -> std::io::Result<usize>;
    fn precalculate_size(&self) -> usize;
}

// TODO: These should be autogenerated instead
impl ToWire for &str {
    fn append(&self, buf: &mut EncodeBuffer) -> std::io::Result<usize> {
        write_prefix(buf, self.len())?;
        buf.write(self.as_bytes())
    }

    fn precalculate_size(&self) -> usize {
        self.len()
    }
}

impl<T> ToWire for &[T]
where
    T: ToWire,
{
    fn append(&self, buf: &mut EncodeBuffer) -> std::io::Result<usize> {
        write_prefix(buf, self.len())?;
        let mut total_size = 0;
        for element in self.iter() {
            total_size += element.append(buf)?;
        }
        Ok(total_size)
    }

    fn precalculate_size(&self) -> usize {
        self.len()
    }
}

impl ToWire for String {
    fn append(&self, buf: &mut EncodeBuffer) -> std::io::Result<usize> {
        write_prefix(buf, self.len())?;
        self.as_str().append(buf)
    }

    fn precalculate_size(&self) -> usize {
        self.len()
    }
}
